<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Dynamo/Client/Store/web/store.war/shared/js/ccLibs/routing-1.0.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: Dynamo/Client/Store/web/store.war/shared/js/ccLibs/routing-1.0.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>//----------------------------------------
/**
 * Routing
 *
 */

define('routing',
  //-------------------------------------------------------------------
  // PACKAGE NAME
  //-------------------------------------------------------------------
  //-------------------------------------------------------------------
  // DEPENDENCIES
  //-------------------------------------------------------------------
  ['jquery',
    'crossroads',
    'hasher',
    'pubsub',
    'ccConstants'
  ],

  //-------------------------------------------------------------------
  // MODULE DEFINTIION
  //-------------------------------------------------------------------
  function($, crossroads, hasher, PubSub, CCConstants) {

    "use strict";

    //----------------------------------------
    // Private Variables
    //----------------------------------------

    // routing variables
    var currentPageId = null,
      currentContextParam = null,
      rootRoute = null,
      pageRoute = null,
      pageContextRoute = null,
      pageContextForCategotyRoute = null,
      productContextRoute = null,
      categoryContextRoute = null,
      pageParameterRoute = null,
      pageRouteParameterRoute = null,
      adminSearchContextRoute = null,
      adminMarketingContextRoute = null,
      currentParameters = null;

    //----------------------------------------
    /**
     * constructor
     */
    function Routing() {
      var self = this;

      $.Topic(PubSub.topicNames.PAGE_LAYOUT_SERVER_ERROR).subscribe(self.handleServerError.bind(self));
      // ------------------------------------------
      // route definitions
      /*
       * Root route.  Needed so the home/ page layout will load.
       *
       * TODO need to handle the following routes somehow:
       * http://localhost:8080/index.html/
       * http://localhost:8080/index.html/#
       * http://localhost:8080/index.html/#/
       */
      rootRoute = crossroads.addRoute('/', null, 1000);
      rootRoute.matched.add(self.onPageContextMatch.bind(self));

      /*
       * Page route with context and parameter. Triggered when all the three exists.
       */
      pageParameterRoute = crossroads.addRoute('/:seo_slug*:/{pageId}/{contextId}?{parameters}', null, 500);
      pageParameterRoute.matched.add(self.onPageContextAndParameterMatch.bind(self));

      /*
       * Page type route.
       *
       * TODO This part needs to be reviewed.  Possibly removed.
       * I don't see this being used ever.  The page type ID doesn't seem
       * like it would be alone in the requset.
       */
      pageRoute = crossroads.addRoute('{pageId}', null, 500);
      pageRoute.matched.add(self.onPageOnlyMatch.bind(self));

      /*
       * Page route with context. This is likely to be used the most (for now?).
       * This is a page type ID (e.g,. category) with a context ID (e.g.,
       * catFireside).*/
      pageContextRoute = crossroads.addRoute('/:seo_slug*:/{pageId}/{contextId}', null, 200);
      pageContextRoute.matched.add(self.onPageContextMatch.bind(self));

      /*
       * Page route with context. This may be used by the catalog page if the collection is provided as well.
       * This is a catalog page with a context ID (e.g.,
       * /appleCatalog/collection/cat10001).*/
      pageContextForCategotyRoute = crossroads.addRoute('/:seo_slug*:/catalog/{catalogId}/collection/{collectionId}', null, 300);
      pageContextForCategotyRoute.matched.add(self.onCatalogContextMatch.bind(self));

      /*
       * Page route with parameter. This is used in the end search.
       * This is a page type ID (usually searchresults) with one or more parameters
       * (e.g., Ntt, No, Nrpp)
       */
      pageParameterRoute = crossroads.addRoute('/:seo_slug*:/{pageId}?{parameters}', null, 200);
      pageParameterRoute.matched.add(self.onPageParameterMatch.bind(self));

      /*
       * Page route with parameter. This is used in the end search.
       * This is a page type ID (usually searchresults) with trailing slash followed by one or more parameters
       * (e.g., Ntt, No, Nrpp)
       */
      pageRouteParameterRoute = crossroads.addRoute('/:seo_slug*:/{pageId}/?{parameters}', null, 200);
      pageRouteParameterRoute.matched.add(self.onPageParameterMatch.bind(self));

      /*
       * Product page route with context. This is used for triggering a page view change
       * whenever there is navigation between products. This has to be higher in priority to
       * the page context match.
       */
      productContextRoute = crossroads.addRoute('/:seo_slug*:/product/{contextId}', null, 500);
      productContextRoute.matched.add(self.onProductContextMatch.bind(self));

      /*
       * Category page route with context. This is used for loading the category
       * pages with pagination. This has to be higher in priority to
       * the actual context match as this is supposed to take care of all the
       * extra params in the URL rather than just send them to the SEO slug.
       */
      categoryContextRoute = crossroads.addRoute('/:seo_slug*:/category/{contextId}/:pageNumber:', null, 500);
      categoryContextRoute.matched.add(self.onCategoryContextMatch.bind(self));

      /*
       * For the Admin application's Search tab, we need to support multi-level context.
       * This should match before the more-generic pageContextRoute route.
       */
      adminSearchContextRoute = crossroads.addRoute('/search/{contextId*}', null, 500);
      adminSearchContextRoute.matched.add(self.onPageContextMatch.bind(self, "", "search"));

      /**
       * For the Admin application's Marketing tab, we need to support multi-level context.
       * This should match before the more-generic pageContextRoute route.
       */
      adminMarketingContextRoute = crossroads.addRoute('/marketing/{contextId*}', null, 500);
      adminMarketingContextRoute.matched.add(self.onPageContextMatch.bind(self, "", "marketing"));

      /*
       * This all sets up hasher to do it's thing.  Add a parsing method [1],
       * listen for changes with that parsing method, then initialize (run)
       * Hasher.
       *
       * [1] Maybe there's something clever we want to do here to track the
       * hash values, or something else?  But this is obviously where the old
       * and new values are available for any cleverness.
       */
      function parseHash(newHash, oldHash) {
        var eventData = {'oldHash' : oldHash, 'newHash' : newHash};
        $.Topic(PubSub.topicNames.UPDATE_HASH_CHANGES).publish(eventData);
        crossroads.parse(newHash);
      }

      hasher.prependHash = CCConstants.URL_PREPEND_HASH;
      hasher.initialized.add(parseHash);
      hasher.changed.add(parseHash);
      hasher.init();


      return (self);
    }

    // ----------------------------------------
    /**
     * Initialize CrossroadsJS and Hasher to listen for HASH URL change events.
     * When the URL changes, a new page model will be loaded.
     *
     * extra credit: can we cache this view model to avoid trips to the server?
     */

    /**
     * Handle the case when layout container load returns an error response.
     */
    Routing.prototype.handleServerError = function(args) {
      // set this to null so we'll reload when the server comes back
      currentPageId = null;
      currentContextParam = null;
    };

    /**
     * Does a data-only request to the server.
     * When that data is returned, publishes a PAGE_CONTEXT_CHANGED
     * message containing the server response.
     *
     * data - expected set of values is the following:
     *  pageId
     *    String of the page type ID to load (e.g., category, product, etc.).
     *  contextId
     *    String of the context ID (e.g., category ID, product ID, etc.).
     *  previousContextId
     *    String of the previous context ID.
     */
    Routing.prototype.handleContextChanged = function(data) {
      // Do a "data only" request, last param is true meaning data only.
      $.Topic(PubSub.topicNames.PAGE_CONTEXT_CHANGED).publish(data);
    }; // handleContextData

    /**
     * Listens for viewChanged events
     * Loads the current view model for the view to which we have changed.
     *
     * When we map a view model twice it causes infinite recursion in
     * knockout.mapping. To work around the issue we're just making a new
     * layout view model each time and updating just the regions property
     * on our local model.
     *
     * data - expected set of values is the following:
     *  pageId
     *    String of the page type ID to load (e.g., category, product, etc.).
     *  contextId
     *    String of the context ID (e.g., category ID, product ID, etc.).
     */
    Routing.prototype.handleViewChanged = function(data) {
      $.Topic(PubSub.topicNames.PAGE_VIEW_CHANGED).publish(data);
    }; // handleViewChanged

    /**
     *
     * Listens for the parameter change.
     * data - expected set of values:
     *  pageId
     *    String of the page type ID to load
     *  parameters
     *    String of parameters in amp(&amp;) separated values
     */
    Routing.prototype.handleParametersChanged = function(data) {
      $.Topic(PubSub.topicNames.PAGE_PARAMETERS_CHANGED).publish(data);
    };
    /**
    *
    * Listens for the parameter change.
    * data - expected set of values:
    *  pageId
    *    String of the page type ID to load
    *  parameters
    *    String of parameters in amp(&amp;) separated values
    */
   Routing.prototype.handlePageContextAndParametersChanged = function(data) {
     $.Topic(PubSub.topicNames.PAGE_CONTEXT_AND_PARAMETERS_CHANGED).publish(data);
   };
    /**
     * Matcher method for routing to decide which event to process.
     *
     * pageId
     *   String of the page type ID to load (e.g., category, product, etc.).
     * contextId
     *   String of the context ID (e.g., category ID, product ID, etc.).
     */
    Routing.prototype.onPageContextMatch = function(slug, pageId, contextId) {
      if (typeof pageId == 'undefined') {
        pageId = 'home';
      }
      var eventData = {
        'pageId': pageId,
        'contextId': contextId,
        'seoslug': slug,
        'previousContextId': currentContextParam
      };
      currentParameters = null;
      if (pageId !== currentPageId  || contextId == undefined) {
        // If page id changes, fire a viewChanged event, including the context
        // param if it exists
        this.handleViewChanged(eventData);
        currentPageId = pageId;
      } else {
        // Otherwise, if the context param has changed, fire a context param
        // changed event We don't want to fire both a context param change and
        // view change event at the same time since its an extra trip to the
        // server.
        this.handleContextChanged(eventData);
        // Update the current context param
        currentContextParam = contextId;
      }
      // For discerning code that just cares if the page has changed and doesn't want to
      // deal with individual context or view change events
      $.Topic(PubSub.topicNames.PAGE_CHANGED).publish(eventData);
    }; // onPageContextMatch

    /**
     * Matcher method for routing to decide which event to process.
     *
     * catalogId
     *   String of the catalog ID to load (e.g., masterCatalog, customCatalog1, etc.).
     * collectionId
     *   String of the collection ID (e.g., cat10001, cat20002, etc.).
     */
    Routing.prototype.onCatalogContextMatch = function(slug, catalogId, collectionId) {
        var eventData = {
          'pageId': 'catalog',
          'contextId': catalogId + '/collection/' + collectionId,
          'seoslug': slug,
          'previousContextId': currentContextParam
        };
        if ('catalog' !== currentPageId  || collectionId == undefined) {
          // If page id changes, fire a viewChanged event, including the context
          // param if it exists
          this.handleViewChanged(eventData);
          currentPageId = 'catalog';
        } else {
          // Otherwise, if the context param has changed, fire a context param
          // changed event We don't want to fire both a context param change and
          // view change event at the same time since its an extra trip to the
          // server.
          this.handleContextChanged(eventData);
          // Update the current context param
          currentContextParam = collectionId;
        }
        // For discerning code that just cares if the page has changed and doesn't want to
        // deal with individual context or view change events
        $.Topic(PubSub.topicNames.PAGE_CHANGED).publish(eventData);
      };

   /**
    *
    * Matcher method for routing a product page and put all the relevant data
    * as event data.
    *
    * slug
    *   slug assigned to product
    * pageNumber
    *   String of the current page number
    */
    Routing.prototype.onProductContextMatch = function(slug, contextId) {
      var pageId = 'product';
      var eventData = {
        'pageId': pageId,
        'contextId': contextId,
        'seoslug': slug,
        'previousContextId': currentContextParam
      };
      // Setting the page id and the context to the current values
      currentPageId = pageId;
      currentContextParam = contextId;
      currentParameters = null;
      this.handleViewChanged(eventData);
      // For discerning code that just cares if the page has changed and doesn't want to
      // deal with individual context or view change events
      $.Topic(PubSub.topicNames.PAGE_CHANGED).publish(eventData);
    };

    /**
    *
    * Matcher method for routing a category page and put all the relevant data
    * as event data.
    *
    * contextId
    *   String of the context ID (e.g., category ID, product ID, etc.).
    * pageNumber
    *   String of the current page number
    * sortOrder
    *   String of the current sort order
    */
    Routing.prototype.onCategoryContextMatch = function(slug, contextId, pageNumber) {
      var pageId = 'category';
      var eventData = {
        'pageId': pageId,
        'contextId': contextId,
        'seoslug': slug,
        'previousContextId': currentContextParam
      };
      var paginationOnlyChange = false;
      currentParameters = null;
      // Check whether this is a pagination/sort order only change
      if ((pageId == currentPageId) &amp;&amp; (contextId == currentContextParam)) {
        paginationOnlyChange = true;
      }
      // Handle the pagination
      $.Topic(PubSub.topicNames.PAGE_PAGINATION_CHANGE).publish(
          {
            page: pageNumber,
            paginationOnly: paginationOnlyChange
          },[{message:"success"}]);
      if (pageId !== currentPageId || contextId !== currentContextParam) {
        // If page or context id changes, fire a viewChanged event, including the context
        // param if it exists
        this.handleViewChanged(eventData);
        currentPageId = pageId;
        currentContextParam = contextId;
      } else {
        // Otherwise, fire a context param changed event. We don't want
        // to fire both a context param change and view change event
        // at the same time since its an extra trip to the server.

        this.handleContextChanged(eventData);
        // Update the current context param
        currentContextParam = contextId;
      }
      // For discerning code that just cares if the page has changed and doesn't want to
      // deal with individual context or view change events
      $.Topic(PubSub.topicNames.PAGE_CHANGED).publish(eventData);
    };

    /**
     *
     * Matcher method for routing to get all the parameters and put it in a page
     *
     * pageId
     *   String of the page type ID to load
     * parameters
     *   List of parameters to be sent along with the page
     */
    Routing.prototype.onPageParameterMatch = function(slug, pageId, parameters) {
      var eventData = {
        'pageId': pageId,
        'seoslug': slug,
        'parameters': parameters
      };

      if (pageId !== currentPageId) {
        // If page id changes, fire a viewChanged event, including the parameters
        // if they exists
        this.handleViewChanged(eventData);
        currentPageId = pageId;
        currentParameters = parameters;
      } else if (parameters !== currentParameters) {
        // Otherwise, if the current parameters has changed, fire a parameters
        // changed event We don't want to fire both a context param change and
        // view change event at the same time since its an extra trip to the
        // server.
        this.handleParametersChanged(eventData);
        // Update the current context param
        currentParameters = parameters;
      }
      // For discerning code that just cares if the page has changed and doesn't want to
      // deal with individual context or view change events
      $.Topic(PubSub.topicNames.PAGE_CHANGED).publish(eventData);
    };


   /**
    *
    * Matcher method for routing to capture the parameters or context or page change
    *
    * pageId
    *   String of the page type ID to load
    * contextId
    *   String of the context ID (e.g., category ID, product ID, etc.).
    * parameters
    *   List of parameters to be sent along with the page
    */
    Routing.prototype.onPageContextAndParameterMatch = function(slug, pageId, contextId, parameters) {
      var eventData = {
        'pageId': pageId,
        'contextId': contextId,
        'seoslug': slug,
        'parameters': parameters
      };
      if (pageId !== currentPageId) {
        // If page id changes, fire a viewChanged event, including the context
        // param if it exists
        this.handleViewChanged(eventData);
        currentPageId = pageId;
        currentContextParam = contextId;
        currentParameters = parameters;
      } else if (contextId !== currentContextParam) {
        // Otherwise, if the context param has changed, fire a context param
        // changed event We don't want to fire both a context param change and
        // view change event at the same time since its an extra trip to the
        // server.
        this.handleContextChanged(eventData);
        // Update the current context param
        currentContextParam = contextId;
        currentParameters = parameters;
      } else if (parameters !== currentParameters) {
        // Otherwise, if the current parameters have changed, fire a parameters changed
        // event We don't want to fire both a context param change and
        // view change event at the same time since its an extra trip to the
        // server.
        this.handleParametersChanged(eventData);
        // Update the current context param
        currentParameters = parameters;
      }
      // For discerning code that just cares if the page has changed and doesn't want to
      // deal with individual context or view change events
      $.Topic(PubSub.topicNames.PAGE_CHANGED).publish(eventData);

    };

    Routing.prototype.onPageOnlyMatch = function(pageId) {
      this.onPageContextMatch(undefined, pageId, undefined);
    };

    return Routing;
  });
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-ccKoErrorWrapper.html">ccKoErrorWrapper</a></li><li><a href="module-ccKoExtensions.html">ccKoExtensions</a></li></ul><h3>Classes</h3><ul><li><a href="Address.html">Address</a></li><li><a href="CartViewModel.html">CartViewModel</a></li><li><a href="DynamicProperty.html">DynamicProperty</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="GiftCardViewModel.html">GiftCardViewModel</a></li><li><a href="GiftProductListingViewModel.html">GiftProductListingViewModel</a></li><li><a href="ko.bindingHandlers.background.html">background</a></li><li><a href="ko.bindingHandlers.carouselSwipe.html">carouselSwipe</a></li><li><a href="ko.bindingHandlers.ccForm.html">ccForm</a></li><li><a href="ko.bindingHandlers.ccLink.html">ccLink</a></li><li><a href="ko.bindingHandlers.ccValidation.html">ccValidation</a></li><li><a href="ko.bindingHandlers.checkbox.html">checkbox</a></li><li><a href="ko.bindingHandlers.chosen.html">chosen</a></li><li><a href="ko.bindingHandlers.contextResourcesNamespace.html">contextResourcesNamespace</a></li><li><a href="ko.bindingHandlers.currency.html">currency</a></li><li><a href="ko.bindingHandlers.datepicker.html">datepicker</a></li><li><a href="ko.bindingHandlers.datepopover.html">datepopover</a></li><li><a href="ko.bindingHandlers.draggable.html">draggable</a></li><li><a href="ko.bindingHandlers.droppable.html">droppable</a></li><li><a href="ko.bindingHandlers.fade.html">fade</a></li><li><a href="ko.bindingHandlers.hover.html">hover</a></li><li><a href="ko.bindingHandlers.imageSource.html">imageSource</a></li><li><a href="ko.bindingHandlers.imageZoom.html">imageZoom</a></li><li><a href="ko.bindingHandlers.localeText.html">localeText</a></li><li><a href="ko.bindingHandlers.makeAccess.html">makeAccess</a></li><li><a href="ko.bindingHandlers.modal.html">modal</a></li><li><a href="ko.bindingHandlers.modalTabbingContraint.html">modalTabbingContraint</a></li><li><a href="ko.bindingHandlers.onRender.html">onRender</a></li><li><a href="ko.bindingHandlers.popeditor.html">popeditor</a></li><li><a href="ko.bindingHandlers.popover.html">popover</a></li><li><a href="ko.bindingHandlers.productImageSource.html">productImageSource</a></li><li><a href="ko.bindingHandlers.propertyEditor.html">propertyEditor</a></li><li><a href="ko.bindingHandlers.radio.html">radio</a></li><li><a href="ko.bindingHandlers.richTextEditor.html">richTextEditor</a></li><li><a href="ko.bindingHandlers.scrollAffix.html">scrollAffix</a></li><li><a href="ko.bindingHandlers.select2.html">select2</a></li><li><a href="ko.bindingHandlers.select2Tags.html">select2Tags</a></li><li><a href="ko.bindingHandlers.selectable.html">selectable</a></li><li><a href="ko.bindingHandlers.slickList.html">slickList</a></li><li><a href="ko.bindingHandlers.slide.html">slide</a></li><li><a href="ko.bindingHandlers.slider.html">slider</a></li><li><a href="ko.bindingHandlers.spectrum.html">spectrum</a></li><li><a href="ko.bindingHandlers.tagsInput.html">tagsInput</a></li><li><a href="ko.bindingHandlers.textCheck.html">textCheck</a></li><li><a href="ko.bindingHandlers.timepicker.html">timepicker</a></li><li><a href="ko.bindingHandlers.triggerMessage.html">triggerMessage</a></li><li><a href="ko.bindingHandlers.validatableTarget.html">validatableTarget</a></li><li><a href="ko.bindingHandlers.validatableValue.html">validatableValue</a></li><li><a href="ko.bindingHandlers.widgetLocaleText.html">widgetLocaleText</a></li><li><a href="koValidation.alphaNumeric.html">alphaNumeric</a></li><li><a href="koValidation.alphaNumericNoSpaces.html">alphaNumericNoSpaces</a></li><li><a href="koValidation.alphaNumericNoSpacesWithSeperators.html">alphaNumericNoSpacesWithSeperators</a></li><li><a href="koValidation.alphaNumericWithSeperators.html">alphaNumericWithSeperators</a></li><li><a href="koValidation.bool.html">bool</a></li><li><a href="koValidation.creditcard.html">creditcard</a></li><li><a href="koValidation.cvv.html">cvv</a></li><li><a href="koValidation.endmonth.html">endmonth</a></li><li><a href="koValidation.endyear.html">endyear</a></li><li><a href="koValidation.importFileName.html">importFileName</a></li><li><a href="koValidation.laterDate.html">laterDate</a></li><li><a href="koValidation.match.html">match</a></li><li><a href="koValidation.mediaZipFileName.html">mediaZipFileName</a></li><li><a href="koValidation.number.html">number</a></li><li><a href="koValidation.observablePattern.html">observablePattern</a></li><li><a href="koValidation.password.html">password</a></li><li><a href="koValidation.price.html">price</a></li><li><a href="koValidation.propertyIdAlreadyInUse.html">propertyIdAlreadyInUse</a></li><li><a href="koValidation.propertyNameAlreadyInUse.html">propertyNameAlreadyInUse</a></li><li><a href="koValidation.restrictSlashCharacters.html">restrictSlashCharacters</a></li><li><a href="koValidation.startmonth.html">startmonth</a></li><li><a href="koValidation.startyear.html">startyear</a></li><li><a href="koValidation.uniqueTrimmed.html">uniqueTrimmed</a></li><li><a href="koValidation.uniqueTrimmedCaseInsensitive.html">uniqueTrimmedCaseInsensitive</a></li><li><a href="koValidation.url.html">url</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.addTemplate.html">addTemplate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccDate.html">ccDate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccDateTime.html">ccDateTime</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccNumber.html">ccNumber</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.disabled.html">disabled</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.element.html">element</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.embeddedAssistance.html">embeddedAssistance</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.inTabFlow.html">inTabFlow</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.setContextVariable.html">setContextVariable</a></li><li><a href="NavStateViewModel.html">NavStateViewModel</a></li><li><a href="OrderHistoryViewModel.html">OrderHistoryViewModel</a></li><li><a href="OrderViewModel.html">OrderViewModel</a></li><li><a href="ParentOrganisation.html">ParentOrganisation</a></li><li><a href="ProductListingSearchViewModel.html">ProductListingSearchViewModel</a></li><li><a href="ProductListingViewModel.html">ProductListingViewModel</a></li><li><a href="ProductViewModel.html">ProductViewModel</a></li><li><a href="PubSub.topicNames.html">topicNames</a></li><li><a href="resetCVV.html">resetCVV</a></li><li><a href="resetPaymentDetails.html">resetPaymentDetails</a></li><li><a href="SearchRestClient.html">SearchRestClient</a></li><li><a href="UserViewModel.html">UserViewModel</a></li><li><a href="WidgetViewModel.html">WidgetViewModel</a></li><li><a href="WishlistContentViewModel.html">WishlistContentViewModel</a></li></ul><h3>Namespaces</h3><ul><li><a href="ko.bindingHandlers.html">bindingHandlers</a></li><li><a href="ko.extenders.html">extenders</a></li><li><a href="koValidation.html">koValidation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CCEETagProcessor">CCEETagProcessor</a></li><li><a href="global.html#isValidDeterminewhetherornotthepaymentdetailsobjectisvalidbasedonthevalidityofitscomponentparts.Thiswillnotcauseerrormessagestobedisplayedforanyobservablevaluesthatareunchangedandhaveneverreceivedfocusontherelatedformfield(s).">isValid
Determine whether or not the payment details object is valid
based on the validity of its component parts. This will not
cause error messages to be displayed for any observable values
that are unchanged and have never received focus on the 
related form field(s).</a></li><li><a href="global.html#validatePaymentDetailsForceallrelevantmemberobservablestoperformtheirvalidationnow&displaytheerrors(ifany)">validatePaymentDetails
Force all relevant member observables to perform their
validation now & display the errors (if any)</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a> on Mon Oct 10 2016 10:49:03 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
