<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Dynamo/Client/Store/web/store.war/shared/js/ccLibs/cc-paginated.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: Dynamo/Client/Store/web/store.war/shared/js/ccLibs/cc-paginated.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * @fileoverview URL based pagination (Extension of existing pagination) 
 * Provides an extended Pagination functionality that can
 * be used by different components to implement URL based pagination.
 * Standard formats for url is /1 or with ?page=1
 * 
 *
 */
define(
  //---------------------------------------------------------------------------
  // PACKAGE NAME
  //---------------------------------------------------------------------------
  'ccPaginated',
  //---------------------------------------------------------------------------
  // DEPENDENCIES
  //---------------------------------------------------------------------------
  [ 'knockout', 'pubsub', 'navigation', 'crossroads', 'ccConstants'],
  //---------------------------------------------------------------------------
  // MODULE DEFINITION
  //---------------------------------------------------------------------------
  function(ko, PubSub, navigation, crossroads, CCConstants) {

    "use strict";

    // ------------------------------------------------------------------------
    // View Model
    // ------------------------------------------------------------------------

    /**
     * Creates a paginated view model.
     * 
     * @class The paginated view model used to implement pagination and
     *        sorting functionality.
     * @name ccPaginated
     * @private
     *           
     * @property {boolean} active=false Active flag.
     * @property {integer} pageNumber=1 The current page number.
     * @property {observable&lt;string>} pageId The page ID.
     * @property {observable&lt;string>} contextId The context ID.
     * @property {observable&lt;boolean>} paginationOnly Pagination only flag.
     * @property {observable&lt;string>} seoslug SEO slug.
     * @property {observable&lt;string>} previousHash Previous URL hash.
     * @property {observable&lt;string>} currentHash Current URL hash.
     * @property {observable&lt;boolean>} isMobileView Mobile view flag.
     * @property {observable&lt;integer>} paginationType=0 Pagination type.
     * @property {integer} targetPage=1 Target page.
     * @property {boolean} clearOnLoad=false Clear on load?
     * @property {integer} itemsPerPage=40 Number of items per page.
     * @property {integer} blockSize=40 Number of items per block.
     * @property {integer} pageBatchSize=1 Page batch size.
     * @property {integer} pageWindowSize=5 Page window size.
     * @property {integer} startIndex=0 Start index.
     * @property {integer} lastIndex=4 Last index.
     * @property {integer} pageIndex=0 Page index.
     * @property {integer} middlePageOffset=0 Middle page offset.
     * @property {boolean} focusPage=false Is this page in focus.
     * @property {Object[]} pages The list of pages.
     * @property {boolean} scrollToTop=true Scroll to top of page?
     * @property {observableArray&lt;Object>} sortOptions The list of sort options.
     * @property {observable&lt;integer>} currentPage=0 Current page being displayed.
     * @property {observable&lt;integer>} totalNumber=0 Total number of items.
     * @property {observableArray&lt;Object>} data The raw data to be paginated.
     * @property {observable&lt;string>} sortDirectiveProp='displayName' Sort directive property.
     * @property {observable&lt;string>} sortDirectiveOrder='asc' Sort directive order - 'asc' or 'desc'.
     * @property {observable&lt;integer>} totalNumberOfPages=0 Total number of pages.
     * @property {observable&lt;integer>} pageStartIndex Start page index.
     * @property {observable&lt;integer>} pageEndIndex End page index.
     * @property {observable&lt;integer>} clickedPage=-1 Clicked page.
     *   
     */
    function CCPaginated() {
      var self = this;
      self.active = false;
      self.pageNumber = 1;
      self.pageId = ko.observable("");
      self.contextId = ko.observable("");
      self.paginationOnly = ko.observable(false);
      self.seoslug = ko.observable("");
      self.previousHash = ko.observable("");
      self.currentHash = ko.observable("");
      self.isMobileView = ko.observable(false);
      // Pagination type handler.
      // 1 = ...page/&lt;PageNumber>. This one needs a contextId as well to work
      // 2 = ...page?parameter&amp;page=&lt;PageNumber>
      self.paginationType = ko.observable(0);
      
      self.targetPage = 1;
      self.clearOnLoad = false;
      self.itemsPerPage = 40;
      self.blockSize = 40;
      self.pageBatchSize = 1;
      self.data = ko.observableArray().extend({ deferred: true });
      self.pageWindowSize = 5;
      self.startIndex = 0;
      self.lastIndex = self.pageWindowSize - 1;
      self.pageIndex = 0;
      self.middlePageOffset = 0;
      self.focusPage = false;

      self.pages = ko.computed(self.pagesFunction, self);
      
      self.scrollToTop = true;
      
      self.currentPage(1);
      self.firstPageIndex(1);
      self.totalNumber(0);
    
      self.sortDirectiveProp('displayName');
      self.sortDirectiveOrder('asc');
      self.totalNumberOfPages(0);

      self.clickedPage(-1);
      
    }

    /**
     * Possible sorting options. Each sorting option should have:
     * id: The property name to sort by.
     * displayText: The display name of the property.
     * order (observable): The asc/desc ordering of the property.
     */
    CCPaginated.prototype.sortOptions = ko.observableArray([]);
    
    CCPaginated.prototype.currentPage = ko.observable(0);
    CCPaginated.prototype.totalNumber = ko.observable(0);
    CCPaginated.prototype.firstPageIndex = ko.observable(1);
    CCPaginated.prototype.data = ko.observableArray([]).extend({ deferred: true });

    CCPaginated.prototype.sortDirectiveProp = ko.observable('displayName');
    CCPaginated.prototype.sortDirectiveOrder = ko.observable('asc');
    CCPaginated.prototype.totalNumberOfPages = ko.observable(0);
    CCPaginated.prototype.pageStartIndex = ko.observable();
    CCPaginated.prototype.pageEndIndex = ko.observable();
    CCPaginated.prototype.clickedPage = ko.observable(-1);

    /**
     * Update the pagination based on the paginationType.
     * The function interpolates the URL based on the pageId, contextId, 
     * pageNumber, parameters
     * @private
     * @function ccPaginated#updatePagination
     * @returns {string} The new URL, containing the pagination data.
     */
    CCPaginated.prototype.updatePagination = function(pageNumber) {
      var self = this;
      var url = "" 
      if (CCConstants.ALLOW_HASHBANG) {
         url += CCConstants.URL_HASH_SIGN + CCConstants.URL_PREPEND_HASH;
      }
      if (this.paginationType() == 1 &amp;&amp; this.contextId()) {
        // Using the normal context routing
        if (self.seoslug() != undefined) {
          var pageContextRoute = crossroads.addRoute('/:seo_slug:/{pageId}/{contextId}/:pageNumber:');
          // Interpolate it to generate page number based URL
          url += pageContextRoute.interpolate({seo_slug: this.seoslug(), pageId: this.pageId(), contextId: this.contextId(), pageNumber: pageNumber});  
        }
        else {
          var pageContextRoute = crossroads.addRoute('/{pageId}/{contextId}/:pageNumber:');
          // Interpolate it to generate page number based URL
          url += pageContextRoute.interpolate({pageId: this.pageId(), contextId: this.contextId(), pageNumber: pageNumber});  
        }
        
        return navigation.getPathWithLocale(url);
      } else if (this.paginationType() == 2) {
        // Using the normal context routing
        var pageContextRoute = crossroads.addRoute('/{pageId}?{parameters}');
        var parameters = "";
        var hasPageNumber = false;
        for (var key in this.parameters) {
          if (this.parameters.hasOwnProperty(key)) {
            if (key == "page") {
              this.parameters[key] = pageNumber;
              hasPageNumber = true;
            }
            parameters += key + "=" + this.parameters[key] + "&amp;";
          }
        }
        parameters = parameters.substring(0, parameters.length - 1);
        if (!hasPageNumber) {
          parameters += "&amp;page=" + pageNumber;
        }
        // Interpolate it to generate page number based URL
        url += pageContextRoute.interpolate({seo_slug: this.seoslug(), pageId: this.pageId(), parameters: parameters});
        return navigation.getPathWithLocale(url);
      } else if (this.paginationType() == 3) {
        url = CCConstants.AGENT_BASE_CONTEXT + '/' + CCConstants.URL_HASH_SIGN + CCConstants.URL_PREPEND_HASH;
        // Using the normal context routing
        var pageContextRoute = crossroads.addRoute('/{pageId}/{contextId}?{parameters}');
        var parameters = "";
        var hasPageNumber = false;
        for (var key in this.parameters) {
          if (this.parameters.hasOwnProperty(key)) {
            if (key == "page") {
              this.parameters[key] = pageNumber;
              hasPageNumber = true;
            }
            parameters += key + "=" + this.parameters[key] + "&amp;";
          }
        }
        parameters = parameters.substring(0, parameters.length - 1);
        if (!hasPageNumber) {
          if(parameters) {
            parameters += "&amp;";
          }
          parameters += "page=" + pageNumber;
        }
        // Interpolate it to generate page number based URL
        url += pageContextRoute.interpolate({pageId: this.pageId(), contextId: this.contextId(), parameters: parameters});
        return navigation.getPathWithLocale(url);
      } else {
        return "";
      }
    };

    /**
     * Load the list of products.
     * @private
     * @function ccPaginated#load
     * @param {boolean} delayClear Delay setting the &lt;code>currentPage&lt;/code>
     * and &lt;code>totalNumberOfPages&lt;/code> properties until after the page
     * is retrieved?
     */
    CCPaginated.prototype.load = function(delayClear) {
      if (delayClear) {
        this.clearData();
        this.clearOnLoad = true;
      } else {
        this.clearData();
        if (this.pageNumber) {
          this.totalNumberOfPages(this.pageNumber);
          this.firstPageIndex(null);
          this.currentPage(this.pageNumber);
          this.firstPageIndex(1);
        }
      }
      this.getPage(this.pageNumber || this.currentPage() || 1);
    };

    /**
     * Function to clean the page URL and pagination data when 
     * the view is changed.
     * @private
     * @function ccPaginated#cleanPage
     */
    CCPaginated.prototype.cleanPage = function() {
      if (this.paginationType() == 1 &amp;&amp; this.contextId()) {
        var pageContextRoute = crossroads.addRoute('/:seo_slug:/{pageId}/{contextId}');
        // Interpolate it to generate default page URL
        var url = pageContextRoute.interpolate({seo_slug: this.seoslug(), pageId: this.pageId(), contextId: this.contextId()});
        navigation.goTo(url);
      } else if (this.paginationType() == 2) {
        var pageContextRoute = crossroads.addRoute('/{pageId}?{parameters}');
        var parameters = "";
        for (var key in this.parameters) {
          if (this.parameters.hasOwnProperty(key)) {
            if (key == "page") {
            } else {
              parameters += key + "=" + this.parameters[key] + "&amp;";
            }
          }
        }
        parameters = parameters.substring(0, parameters.length - 1);
        // Interpolate it to generate default page URL
        var url = pageContextRoute.interpolate({seo_slug: this.seoslug(), pageId: this.pageId(), parameters: parameters});
        navigation.goTo(url);
      } else if (this.paginationType() == 3) {
        // Using the normal context routing
        var pageContextRoute = crossroads.addRoute('/{pageId}/{contextId}?{parameters}');
        var parameters = "";
        for (var key in this.parameters) {
          if (this.parameters.hasOwnProperty(key)) {
            if (key == "page") {
            } else {
            parameters += key + "=" + this.parameters[key] + "&amp;";
            }
          }
        }
        parameters = parameters.substring(0, parameters.length - 1);
        // Interpolate it to generate page number based URL
        var url = pageContextRoute.interpolate({pageId: this.pageId(), contextId: this.contextId(), parameters: parameters});
        navigation.goTo(url);
      }
    };

    /**
     * The first page URL.
     * @private
     * @function ccPaginated#firstPage
     * @returns {string} The URL for page 1.
     */
    CCPaginated.prototype.firstPage = function() {
      return this.updatePagination(this.firstPageIndex());
    };

    /**
     * Take to the first page control.
     * @private
     * @function ccPaginated#goToFirstPageControls
     */
    CCPaginated.prototype.goToFirstPageControls = function() {
      this.initializeIndex();
      return true;
    };

    /**
     * The previous page URL based on the currentPage.
     * @private
     * @function ccPaginated#previousPage
     * @returns {string} The URL of the previous page.
     */
    CCPaginated.prototype.previousPage = function() {
      if (this.currentPage() > this.startIndex + 1) {
        return this.updatePagination(this.currentPage() - 1);
      } else {
        return this.updatePagination(this.currentPage());
      }
    };

    /**
     * The page URL for the given page number.
     * @function ccPaginated#goToPage
     * @param {Object} data The current context data that contains the pageNumber.
     * @private
     * @returns {string} The URL of the given page.
     */
    CCPaginated.prototype.goToPage = function(data) {
      return this.updatePagination(data.pageNumber);
    };
    
    /**
     * Gives the next page URL based on the currentPage.
     * @private
     * @function ccPaginated#nextPage
     * @returns {string} The URL of the next page, or the URL of the current
     * page, if this is the last page.
     */
    CCPaginated.prototype.nextPage = function() {
      if (this.currentPage() &lt;  this.totalNumberOfPages()) {
        return this.updatePagination(this.currentPage() + 1);
      } else {
        return this.updatePagination(this.currentPage());
      }
    };

    /**
     * Gives the last page URL.
     * @private
     * @function ccPaginated#lastPage
     * @returns {string} The URL of the last page.
     */
    CCPaginated.prototype.lastPage = function() {
      return this.updatePagination(this.totalNumberOfPages());
    };

    /**
     * Increments the current page by one.
     * @private
     * @function ccPaginated#incrementPage
     */
    CCPaginated.prototype.incrementPage = function() {
      if(this.currentPage() &lt;  this.totalNumberOfPages()) {
        this.getPage(this.currentPage() + 1);
      }
    };

    /**
     * Gets the specified page of results. Will fetch needed results if they
     * are not already loaded.
     * @param {integer} pageNumber The page number of results to get.
     * @private
     * @function ccPaginated#getPage
     */
    CCPaginated.prototype.getPage = function(pageNumber) {
      if (this.totalNumberOfPages() > 1) {
        this.adjustPageIndex(pageNumber);
      }
      this.adjustStartAndEndPageIndex(pageNumber);
      // Pagination for mobile views
      if(pageNumber !== this.currentPage() &amp;&amp; pageNumber !== this.targetPage &amp;&amp; this.isMobileView()) { 
        $.Topic(PubSub.topicNames.RECORD_PAGINATION_PAGE_CHANGE).publish();
      }
      // Populate all missing items on the page
      if (pageNumber !== this.currentPage()) {
        this.targetPage = pageNumber;
      }
      if (this.clearOnLoad) {
        this.fetchBlock(this.pageStartIndex());
        this.clickedPage(pageNumber);
        this.currentPage(pageNumber);
        return;
      }
      for (var i = this.pageStartIndex(); i &lt; this.pageEndIndex(); i += 1) {
        if (typeof this.data()[i] === 'undefined') {
          if(pageNumber !== this.currentPage()) {
            this.targetPage = pageNumber;
          }
          this.fetchBlock(this.pageStartIndex());
          return;
        }
      }
      this.currentPage(pageNumber);
    };

    /**
     * Function to create a list of pages to display.
     * @private
     * @function ccPaginated#pagesFunction
     * @returns {Object[]} A list of 'page' objects, where each object contains
     * &lt;code>&amp;#123;{pageNumber, selected, focused}&amp;#125;&lt;/code>
     */
    CCPaginated.prototype.pagesFunction = function() {
      var numberOfPages, numberOfFullPages, numberOfPartialPages, pages,
      pageNumber, selected, focused, i, offset = 1, pageIndex;
      if (this.clearOnLoad) {
        this.adjustStartAndEndPageIndex(this.pageNumber);
      }
      if (this.totalNumber()) {
        // Calculate the number of pages
        numberOfFullPages =
        (this.totalNumber() - (this.totalNumber() % this.itemsPerPage)) / this.itemsPerPage;
        numberOfPartialPages = (this.totalNumber() % this.itemsPerPage > 0 ? 1 : 0);
        numberOfPages = numberOfFullPages + numberOfPartialPages;
      } else {
        numberOfPages = 0;
      }
      this.prevTotalNumberOfPages = this.totalNumberOfPages();
      this.totalNumberOfPages(numberOfPages);
      this.adjustPageIndex(this.pageNumber);
      // Create the objects to represent the pages
      pages = [];
      for (i = this.startIndex; (i &lt;= this.lastIndex &amp;&amp; i &lt; this.totalNumberOfPages()); i += 1) {
        pageNumber = i + 1;
        // Determine whether or not this page is currently selected
        selected = pageNumber === this.currentPage();
        focused = (this.focusPage) ? selected : false;
        pageIndex = Math.abs(pageNumber - i - offset);
        offset += 1;
        pages[pageIndex] = 
          {pageNumber: pageNumber, selected: selected, focused: focused};
      }
      // Ignore the page focus the first time we enter a page
      if (!this.focusPage &amp;&amp; pages.length > 0) {
        this.focusPage = true;
      }
      return pages;
    };

    /**
     * Adjust startIndex and lastIndex of the page slice depending on which page
     * is requested to be viewed.
     * @param {integer} pageNumber The page number to be viewed.
     * @private
     * @function ccPaginated#adjustPageIndex
     */
    CCPaginated.prototype.adjustPageIndex = function(pageNumber) {
      var pageOffset = Math.floor(this.pageWindowSize/2);
      if (pageNumber >= this.totalNumberOfPages()) {
        // Reset the page number to the last page
        if (pageNumber > this.totalNumberOfPages()) {
          pageNumber = this.totalNumberOfPages();
        }
        // Handle Last pages
        if (pageNumber == this.totalNumberOfPages()) {
          // Assign the last page index to max
          this.lastIndex = this.totalNumberOfPages() - 1;
          if (this.lastIndex &lt; (this.pageWindowSize - 1)) {
            // Check if the last index size is less than the window size
            // If so set the start index to the first page
            this.startIndex = 0;
          } else {
            // Else set the start index to the previous 5th page
            this.startIndex = this.lastIndex - (this.pageWindowSize - 1);
          }
        }
      } else {
        // All the other pages
        if (pageNumber &lt;= this.pageWindowSize) {
          // When the page number is less than or equal to the page window size
          // Set the start index to the first element
          this.startIndex = 0;
          // Based on the total number of elements set the last index
          if (this.totalNumberOfPages() &lt;= this.pageWindowSize) {
            this.lastIndex = this.totalNumberOfPages() - 1;
          } else {
            this.lastIndex = this.pageWindowSize - 1;
          }
        } else {
          // When the page number is greater than the page window size
          var pageOverflow = this.totalNumberOfPages() - pageNumber;
          if (pageOverflow >= pageOffset) {
            // When there are enough pages after the required page
            this.startIndex = (pageNumber - 1) - pageOffset;
            this.lastIndex = (pageNumber - 1) + pageOffset;
          } else {
            this.startIndex = (pageNumber - 1) - pageOffset - pageOverflow;
            this.lastIndex = (pageNumber - 1) + pageOffset - pageOverflow;
          }
        }
      }
    };

    /**
     * Sorts the list of data. Will sort client side if possible, otherwise
     * data will be loaded from the server in the appropriate order.
     * @param {Object} sorting The sort criteria object.
     * @private
     * @function ccPaginated#sort
     */
    CCPaginated.prototype.sort = function(sorting) {
      var i, sortOrder, sortOptionId, missingData;

      // if the sort order isn't reversible, don't re-sort if the sort order is the same
      var a = this.sortDirectiveOrder();
      var b = sorting.order();
      if (sorting.notReversible &amp;&amp; this.sortDirectiveOrder() == sorting.order()) {
        return;
      }

      if (sorting.maintainSortOrder &amp;&amp; sorting.maintainSortOrder === true) {
        sortOrder = sorting.order();
      }
      else {
        if (sorting.id) {
          if (sorting.order() === "none" || sorting.order() === "desc") {
            sortOrder = "asc";
          } else {
            sortOrder = "desc";
          }
        }
      }

      this.sortDirectiveOrder(sortOrder);

      for (i = 0; i &lt; this.sortOptions().length; i += 1) {
        if (this.sortOptions()[i] === sorting) {
          this.sortOptions()[i].order(sortOrder);
        } else if(!this.sortOptions()[i].maintainSortOrder){
          this.sortOptions()[i].order("none");
        }
      }

      this.sortDirectiveProp(sorting.id);
      
      if (this.paginationType() == 2 || this.paginationType() == 3) {
        var sortKey = 'product.relevance';
        if (sorting.id === 'listPrice') {
          sortKey = 'sku.activePrice';
          sortKey = sortKey + ((sortOrder === 'desc') ? "|1" : "|0");
        }
        this.parameters[CCConstants.SEARCH_SORT_ORDER] = encodeURIComponent(sortKey);  
      }
      
      //If client does not have all the data, clear loaded data and use
      //server request to sort the data.
      if (this.data().length &lt; this.totalNumber() || sorting.serverOnly) {
        this.clearOnLoad = true;
        this.cleanPage();
        this.initializeIndex();
        this.targetPage = 1;
        this.fetchBlock(0);
        return;
      }

      /* in case we paginated and skipped pages, check to see if any
       * items in the array are undefined, if we find one, empty the array */
      $.each(this.data(), function(ii, next) {
        if (!next) {
          missingData = true;
          return false;
        }
      });

      if (missingData) {
        this.clearOnLoad = true;
        this.targetPage = 1;
        this.fetchBlock(0);
        return;
      }

      //Client side sort.
      this.data.sort(this.sortFunction.bind(this));
      this.getPage(1);
    };

    /**
     * Client side sort function for a list of objects.
     * @param {Object} a First compare value.
     * @param {Object} b Second compare value.
     * @returns {integer} Returns 0 if equal, &lt;1 if a should come first,
     * or >1 if a should come second.
     * @private
     * @function ccPaginated#sortFunction
     */
    CCPaginated.prototype.sortFunction = function (a, b) {
      var property, ii, aValue, bValue, order;
      order = this.sortDirectiveOrder() === "desc" ? -1 : 1;
      property = this.sortDirectiveProp() &amp;&amp;
                     this.sortDirectiveProp().split('.');
      aValue = a;
      bValue = b;

      for(ii = 0; ii &lt; property.length; ii += 1) {
        if($.isArray(aValue)) {
          aValue = aValue[0];
        }
        
        if($.isArray(aValue)) {
          aValue = aValue[0];
        }

        aValue = aValue &amp;&amp; aValue[property[ii]];

        if($.isArray(bValue)) {
          bValue = bValue[0];
        }

        bValue = bValue &amp;&amp; bValue[property[ii]];
        
        if($.isArray(bValue)) {
          bValue = bValue[0];
        }
      }

      // If sort values are equal then default to name ascending
      if(aValue === bValue ||
      (typeof aValue === 'string' &amp;&amp; aValue.toLowerCase() === bValue.toLowerCase())) {
        if(a.displayName &amp;&amp; b.displayName){
          aValue = a.displayName &amp;&amp; a.displayName.toString().toLowerCase();
          bValue = b.displayName &amp;&amp; b.displayName.toString().toLowerCase();
        } else if(a.dateTime &amp;&amp; b.dateTime){
          aValue = a.dateTime &amp;&amp; a.dateTime.toLowerCase();
          bValue = b.dateTime &amp;&amp; b.dateTime.toLowerCase();
          order = 1;
        }
      }

      if(aValue === bValue) {
        return 0;
      }

      if(isFinite(aValue) &amp;&amp; isFinite(bValue)) {
        return (parseFloat(aValue) - parseFloat(bValue)) * order;
      }

      return aValue.toString().toLowerCase() > bValue.toString().toLowerCase() ? order : -1 * order;
    };

    /**
     * Adjust the start and last index of the currently viewed page.
     * @private
     * @function ccPaginated#adjustStartAndEndPageIndex
     * @param {integer} pageNumber The page number.
     */
    CCPaginated.prototype.adjustStartAndEndPageIndex = function(pageNumber){
      // Determine the ending index of the items on this page
      this.pageEndIndex(pageNumber * this.itemsPerPage);
      if(this.totalNumber()){
        if (this.pageEndIndex() > this.totalNumber()) {
          this.pageEndIndex(this.totalNumber());
        }
      }
      this.pageStartIndex((pageNumber - 1) * this.itemsPerPage);
    };
    
    /**
     * Initialize startIndex and EndIndex for a given page slice when loaded for 
     * the first time.
     * @private
     * @function ccPaginated#initializeIndex.
     */
    CCPaginated.prototype.initializeIndex = function(){
      this.startIndex = 0;
      this.lastIndex = this.pageWindowSize -1;
      this.clickedPage(1);
    };

    /**
     * Clear the data.
     * @private
     * @function ccPaginated#clearData
     */
    CCPaginated.prototype.clearData = function() {
      this.data([]);
      this.prevTotalNumber = this.totalNumber();
      this.totalNumber(null);
    };

    /**
     * Responsible for adding data to the list of loaded data. This needs to
     * be called by the implementing class.
     * @param {Object[]} pagedData The data to add to the list of loaded data.
     * @param {integer} total The total number of data records that could possibly
     * be loaded.
     * @param {integer} startIndex The starting index of the loaded data.
     * @private
     * @function ccPaginated#addData
     */
    CCPaginated.prototype.addData = function(pagedData, total, startIndex) {
      var dataSet, endIndex, ii;  
      //this if condition is to cover the case where all the items on the last page are deleted
      if(this.pageStartIndex() >0 &amp;&amp; (total &lt; 0 || total === startIndex)){
       total =  this.prevTotalNumber - this.blockSize >= 0 ? (this.prevTotalNumber - this.blockSize) : 0;
       this.removeLastPage();
      }else{
        total = total&lt; 0 ? 0 : total;
      }
      this.totalNumber(total);
      endIndex = startIndex + this.blockSize * this.pageBatchSize;
      if(endIndex > total) {
        endIndex = total;
      }
      if(this.clearOnLoad) {
        dataSet = [];
        this.initializeIndex();
      } else {
        dataSet = this.data();
      }

      if(pagedData) {
        for(ii = 0; ii &lt; pagedData.length; ii += 1) {
          dataSet[ii + startIndex] = pagedData[ii];
        }
      }

      if(this.clearOnLoad) {
        this.data(dataSet);
        this.clearOnLoad = false;
      } else {
        this.data.valueHasMutated();
      }

      if(this.targetPage) {
        if(this.targetPage == 1){
          this.initializeIndex();
        }
        this.adjustStartAndEndPageIndex(this.targetPage);
        //Scroll to the top and switch page.
        if(this.scrollToTop === true) {
          $(window).scrollTop(0);
        }
        // Emptying the firstpage and resetting it
        this.firstPageIndex(null);
        this.currentPage(this.targetPage);
        this.firstPageIndex(1);
        if(this.scrollToTop === true) {
          $(window).scrollTop(0);
        }
        this.targetPage = null;
      } else if (endIndex &lt; this.pageEndIndex()) {
        this.pageEndIndex(endIndex);
      }
    };

    /**
     * Load products using the current sorting order and starting from the
     * specified starting index.
     * @param {integer} startingIndex The index of the first record to load.
     * @function ccPaginated#fetchBlock
     */
    CCPaginated.prototype.fetchBlock = function(startingIndex) {
      throw "Function Not Implemented!";
    };

    /**
     * Function to remove all products in the last page.
     * @function ccPaginated#removeLastPage
     */
    CCPaginated.prototype.removeLastPage = function() {
      this.clearOnLoad = false;
      this.startIndex = (this.startIndex - 1) >= 0 ? this.startIndex - 1 : this.startIndex;
      this.getPage(this.currentPage() - 1);
    };

    /**
     * Reset the sort properties to a default state.
     * @function ccPaginated#sortReset
     */
    CCPaginated.prototype.sortReset = function() {
      this.sortDirectiveProp('displayName');
      this.sortDirectiveOrder('asc');

      $.each(this.sortOptions(), function(ii, value) {
        if(value.id === 'displayName') {
          value.order('asc');
        } else {
          value.order('none');
        }
      });
    };

    return CCPaginated;
  }
);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-ccKoErrorWrapper.html">ccKoErrorWrapper</a></li><li><a href="module-ccKoExtensions.html">ccKoExtensions</a></li></ul><h3>Classes</h3><ul><li><a href="Address.html">Address</a></li><li><a href="CartViewModel.html">CartViewModel</a></li><li><a href="DynamicProperty.html">DynamicProperty</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="GiftCardViewModel.html">GiftCardViewModel</a></li><li><a href="GiftProductListingViewModel.html">GiftProductListingViewModel</a></li><li><a href="ko.bindingHandlers.background.html">background</a></li><li><a href="ko.bindingHandlers.carouselSwipe.html">carouselSwipe</a></li><li><a href="ko.bindingHandlers.ccForm.html">ccForm</a></li><li><a href="ko.bindingHandlers.ccLink.html">ccLink</a></li><li><a href="ko.bindingHandlers.ccValidation.html">ccValidation</a></li><li><a href="ko.bindingHandlers.checkbox.html">checkbox</a></li><li><a href="ko.bindingHandlers.chosen.html">chosen</a></li><li><a href="ko.bindingHandlers.contextResourcesNamespace.html">contextResourcesNamespace</a></li><li><a href="ko.bindingHandlers.currency.html">currency</a></li><li><a href="ko.bindingHandlers.datepicker.html">datepicker</a></li><li><a href="ko.bindingHandlers.datepopover.html">datepopover</a></li><li><a href="ko.bindingHandlers.draggable.html">draggable</a></li><li><a href="ko.bindingHandlers.droppable.html">droppable</a></li><li><a href="ko.bindingHandlers.fade.html">fade</a></li><li><a href="ko.bindingHandlers.hover.html">hover</a></li><li><a href="ko.bindingHandlers.imageSource.html">imageSource</a></li><li><a href="ko.bindingHandlers.imageZoom.html">imageZoom</a></li><li><a href="ko.bindingHandlers.localeText.html">localeText</a></li><li><a href="ko.bindingHandlers.makeAccess.html">makeAccess</a></li><li><a href="ko.bindingHandlers.modal.html">modal</a></li><li><a href="ko.bindingHandlers.modalTabbingContraint.html">modalTabbingContraint</a></li><li><a href="ko.bindingHandlers.onRender.html">onRender</a></li><li><a href="ko.bindingHandlers.popeditor.html">popeditor</a></li><li><a href="ko.bindingHandlers.popover.html">popover</a></li><li><a href="ko.bindingHandlers.productImageSource.html">productImageSource</a></li><li><a href="ko.bindingHandlers.propertyEditor.html">propertyEditor</a></li><li><a href="ko.bindingHandlers.radio.html">radio</a></li><li><a href="ko.bindingHandlers.richTextEditor.html">richTextEditor</a></li><li><a href="ko.bindingHandlers.scrollAffix.html">scrollAffix</a></li><li><a href="ko.bindingHandlers.select2.html">select2</a></li><li><a href="ko.bindingHandlers.select2Tags.html">select2Tags</a></li><li><a href="ko.bindingHandlers.selectable.html">selectable</a></li><li><a href="ko.bindingHandlers.slickList.html">slickList</a></li><li><a href="ko.bindingHandlers.slide.html">slide</a></li><li><a href="ko.bindingHandlers.slider.html">slider</a></li><li><a href="ko.bindingHandlers.spectrum.html">spectrum</a></li><li><a href="ko.bindingHandlers.tagsInput.html">tagsInput</a></li><li><a href="ko.bindingHandlers.textCheck.html">textCheck</a></li><li><a href="ko.bindingHandlers.timepicker.html">timepicker</a></li><li><a href="ko.bindingHandlers.triggerMessage.html">triggerMessage</a></li><li><a href="ko.bindingHandlers.validatableTarget.html">validatableTarget</a></li><li><a href="ko.bindingHandlers.validatableValue.html">validatableValue</a></li><li><a href="ko.bindingHandlers.widgetLocaleText.html">widgetLocaleText</a></li><li><a href="koValidation.alphaNumeric.html">alphaNumeric</a></li><li><a href="koValidation.alphaNumericNoSpaces.html">alphaNumericNoSpaces</a></li><li><a href="koValidation.alphaNumericNoSpacesWithSeperators.html">alphaNumericNoSpacesWithSeperators</a></li><li><a href="koValidation.alphaNumericWithSeperators.html">alphaNumericWithSeperators</a></li><li><a href="koValidation.bool.html">bool</a></li><li><a href="koValidation.creditcard.html">creditcard</a></li><li><a href="koValidation.cvv.html">cvv</a></li><li><a href="koValidation.endmonth.html">endmonth</a></li><li><a href="koValidation.endyear.html">endyear</a></li><li><a href="koValidation.importFileName.html">importFileName</a></li><li><a href="koValidation.laterDate.html">laterDate</a></li><li><a href="koValidation.match.html">match</a></li><li><a href="koValidation.mediaZipFileName.html">mediaZipFileName</a></li><li><a href="koValidation.number.html">number</a></li><li><a href="koValidation.observablePattern.html">observablePattern</a></li><li><a href="koValidation.password.html">password</a></li><li><a href="koValidation.price.html">price</a></li><li><a href="koValidation.propertyIdAlreadyInUse.html">propertyIdAlreadyInUse</a></li><li><a href="koValidation.propertyNameAlreadyInUse.html">propertyNameAlreadyInUse</a></li><li><a href="koValidation.restrictSlashCharacters.html">restrictSlashCharacters</a></li><li><a href="koValidation.startmonth.html">startmonth</a></li><li><a href="koValidation.startyear.html">startyear</a></li><li><a href="koValidation.uniqueTrimmed.html">uniqueTrimmed</a></li><li><a href="koValidation.uniqueTrimmedCaseInsensitive.html">uniqueTrimmedCaseInsensitive</a></li><li><a href="koValidation.url.html">url</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.addTemplate.html">addTemplate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccDate.html">ccDate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccDateTime.html">ccDateTime</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccNumber.html">ccNumber</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.disabled.html">disabled</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.element.html">element</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.embeddedAssistance.html">embeddedAssistance</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.inTabFlow.html">inTabFlow</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.setContextVariable.html">setContextVariable</a></li><li><a href="NavStateViewModel.html">NavStateViewModel</a></li><li><a href="OrderHistoryViewModel.html">OrderHistoryViewModel</a></li><li><a href="OrderViewModel.html">OrderViewModel</a></li><li><a href="ParentOrganisation.html">ParentOrganisation</a></li><li><a href="ProductListingSearchViewModel.html">ProductListingSearchViewModel</a></li><li><a href="ProductListingViewModel.html">ProductListingViewModel</a></li><li><a href="ProductViewModel.html">ProductViewModel</a></li><li><a href="PubSub.topicNames.html">topicNames</a></li><li><a href="resetCVV.html">resetCVV</a></li><li><a href="resetPaymentDetails.html">resetPaymentDetails</a></li><li><a href="SearchRestClient.html">SearchRestClient</a></li><li><a href="UserViewModel.html">UserViewModel</a></li><li><a href="WidgetViewModel.html">WidgetViewModel</a></li><li><a href="WishlistContentViewModel.html">WishlistContentViewModel</a></li></ul><h3>Namespaces</h3><ul><li><a href="ko.bindingHandlers.html">bindingHandlers</a></li><li><a href="ko.extenders.html">extenders</a></li><li><a href="koValidation.html">koValidation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CCEETagProcessor">CCEETagProcessor</a></li><li><a href="global.html#isValidDeterminewhetherornotthepaymentdetailsobjectisvalidbasedonthevalidityofitscomponentparts.Thiswillnotcauseerrormessagestobedisplayedforanyobservablevaluesthatareunchangedandhaveneverreceivedfocusontherelatedformfield(s).">isValid
Determine whether or not the payment details object is valid
based on the validity of its component parts. This will not
cause error messages to be displayed for any observable values
that are unchanged and have never received focus on the 
related form field(s).</a></li><li><a href="global.html#validatePaymentDetailsForceallrelevantmemberobservablestoperformtheirvalidationnow&displaytheerrors(ifany)">validatePaymentDetails
Force all relevant member observables to perform their
validation now & display the errors (if any)</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a> on Mon Oct 10 2016 10:49:02 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
